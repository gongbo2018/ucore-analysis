{"./":{"url":"./","title":"Introduction","keywords":"","body":"# ucore-analysis Piazza页面 Github repo：即本仓库。这里的文档修改会自动同步到github.io和gitbook.io上的页面。 github.io页面：有讨论区 gitbook.io页面 修改日志 20191027：gitbook格式配置完成 const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/":{"url":"lab/lab1/","title":"lab1","keywords":"","body":"lab1 const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/boot/":{"url":"lab/lab1/boot/","title":"boot","keywords":"","body":"boot const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/boot/bootasm.html":{"url":"lab/lab1/boot/bootasm.html","title":"bootasm","keywords":"","body":"编写文档 #include # Start the CPU: switch to 32-bit protected mode, jump into C. # The BIOS loads this code from the first sector of the hard disk into # memory at physical address 0x7c00 and starts executing in real mode # with %cs=0 %ip=7c00. .set PROT_MODE_CSEG, 0x8 # kernel code segment selector .set PROT_MODE_DSEG, 0x10 # kernel data segment selector .set CR0_PE_ON, 0x1 # protected mode enable flag # start address should be 0:7c00, in real mode, the beginning address of the running bootloader .globl start start: .code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment # Set up the important data segment registers (DS, ES, SS). xorw %ax, %ax # Segment number zero movw %ax, %ds # -> Data Segment movw %ax, %es # -> Extra Segment movw %ax, %ss # -> Stack Segment # Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this. seta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -> port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042's P2 port seta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -> port 0x60 outb %al, $0x60 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1 # Switch from real to protected mode, using a bootstrap GDT # and segment translation that makes virtual addresses # identical to physical addresses, so that the # effective memory map does not change during the switch. lgdt gdtdesc movl %cr0, %eax orl $CR0_PE_ON, %eax movl %eax, %cr0 # Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg .code32 # Assemble for 32-bit mode protcseg: # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # -> DS: Data Segment movw %ax, %es # -> ES: Extra Segment movw %ax, %fs # -> FS movw %ax, %gs # -> GS movw %ax, %ss # -> SS: Stack Segment # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00) movl $0x0, %ebp movl $start, %esp call bootmain # If bootmain returns (it shouldn't), loop. spin: jmp spin # Bootstrap GDT .p2align 2 # force 4 byte alignment gdt: SEG_NULLASM # null seg SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff) # code seg for bootloader and kernel SEG_ASM(STA_W, 0x0, 0xffffffff) # data seg for bootloader and kernel gdtdesc: .word 0x17 # sizeof(gdt) - 1 .long gdt # address gdt const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/boot/bootmain.html":{"url":"lab/lab1/boot/bootmain.html","title":"bootmain","keywords":"","body":"#include #include #include /* ********************************************************************* * This a dirt simple boot loader, whose sole job is to boot * an ELF kernel image from the first IDE hard disk. * * DISK LAYOUT * * This program(bootasm.S and bootmain.c) is the bootloader. * It should be stored in the first sector of the disk. * * * The 2nd sector onward holds the kernel image. * * * The kernel image must be in ELF format. * * BOOT UP STEPS * * when the CPU boots it loads the BIOS into memory and executes it * * * the BIOS intializes devices, sets of the interrupt routines, and * reads the first sector of the boot device(e.g., hard-drive) * into memory and jumps to it. * * * Assuming this boot loader is stored in the first sector of the * hard-drive, this code takes over... * * * control starts in bootasm.S -- which sets up protected mode, * and a stack so C code then run, then calls bootmain() * * * bootmain() in this file takes over, reads in the kernel and jumps to it. * */ #define SECTSIZE 512 #define ELFHDR ((struct elfhdr *)0x10000) // scratch space /* waitdisk - wait for disk ready */ static void waitdisk(void) { while ((inb(0x1F7) & 0xC0) != 0x40) /* do nothing */; } /* readsect - read a single sector at @secno into @dst */ static void readsect(void *dst, uint32_t secno) { // wait for disk to be ready waitdisk(); outb(0x1F2, 1); // count = 1 outb(0x1F3, secno & 0xFF); outb(0x1F4, (secno >> 8) & 0xFF); outb(0x1F5, (secno >> 16) & 0xFF); outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0); outb(0x1F7, 0x20); // cmd 0x20 - read sectors // wait for disk to be ready waitdisk(); // read a sector insl(0x1F0, dst, SECTSIZE / 4); } /* * * readseg - read @count bytes at @offset from kernel into virtual address @va, * might copy more than asked. * */ static void readseg(uintptr_t va, uint32_t count, uint32_t offset) { uintptr_t end_va = va + count; // round down to sector boundary va -= offset % SECTSIZE; // translate from bytes to sectors; kernel starts at sector 1 uint32_t secno = (offset / SECTSIZE) + 1; // If this is too slow, we could read lots of sectors at a time. // We'd write more to memory than asked, but it doesn't matter -- // we load in increasing order. for (; va e_magic != ELF_MAGIC) { goto bad; } struct proghdr *ph, *eph; // load each program segment (ignores ph flags) ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff); eph = ph + ELFHDR->e_phnum; for (; ph p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset); } // call the entry point from the ELF header // note: does not return ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))(); bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); /* do nothing */ while (1); } const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/":{"url":"lab/lab1/kern/","title":"kern","keywords":"","body":"kern const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/debug/":{"url":"lab/lab1/kern/debug/","title":"debug","keywords":"","body":"debug const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/debug/kmonitor.html":{"url":"lab/lab1/kern/debug/kmonitor.html","title":"kmonitor","keywords":"","body":"#include #include #include #include #include /* * * Simple command-line kernel monitor useful for controlling the * kernel and exploring the system interactively. * */ struct command { const char *name; const char *desc; // return -1 to force monitor to exit int(*func)(int argc, char **argv, struct trapframe *tf); }; static struct command commands[] = { {\"help\", \"Display this list of commands.\", mon_help}, {\"kerninfo\", \"Display information about the kernel.\", mon_kerninfo}, {\"backtrace\", \"Print backtrace of stack frame.\", mon_backtrace}, }; #define NCOMMANDS (sizeof(commands)/sizeof(struct command)) /***** Kernel monitor command interpreter *****/ #define MAXARGS 16 #define WHITESPACE \" \\t\\n\\r\" /* parse - parse the command buffer into whitespace-separated arguments */ static int parse(char *buf, char **argv) { int argc = 0; while (1) { // find global whitespace while (*buf != '\\0' && strchr(WHITESPACE, *buf) != NULL) { *buf ++ = '\\0'; } if (*buf == '\\0') { break; } // save and scan past next arg if (argc == MAXARGS - 1) { cprintf(\"Too many arguments (max %d).\\n\", MAXARGS); } argv[argc ++] = buf; while (*buf != '\\0' && strchr(WHITESPACE, *buf) == NULL) { buf ++; } } return argc; } /* * * runcmd - parse the input string, split it into separated arguments * and then lookup and invoke some related commands/ * */ static int runcmd(char *buf, struct trapframe *tf) { char *argv[MAXARGS]; int argc = parse(buf, argv); if (argc == 0) { return 0; } int i; for (i = 0; i \")) != NULL) { if (runcmd(buf, tf) const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/debug/panic.html":{"url":"lab/lab1/kern/debug/panic.html","title":"panic","keywords":"","body":"#include #include #include #include static bool is_panic = 0; /* * * __panic - __panic is called on unresolvable fatal errors. it prints * \"panic: 'message'\", and then enters the kernel monitor. * */ void __panic(const char *file, int line, const char *fmt, ...) { if (is_panic) { goto panic_dead; } is_panic = 1; // print the 'message' va_list ap; va_start(ap, fmt); cprintf(\"kernel panic at %s:%d:\\n \", file, line); vcprintf(fmt, ap); cprintf(\"\\n\"); cprintf(\"stack trackback:\\n\"); print_stackframe(); va_end(ap); panic_dead: intr_disable(); while (1) { kmonitor(NULL); } } /* __warn - like panic, but don't */ void __warn(const char *file, int line, const char *fmt, ...) { va_list ap; va_start(ap, fmt); cprintf(\"kernel warning at %s:%d:\\n \", file, line); vcprintf(fmt, ap); cprintf(\"\\n\"); va_end(ap); } bool is_kernel_panic(void) { return is_panic; } const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/init/":{"url":"lab/lab1/kern/init/","title":"init","keywords":"","body":"init const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/init/init.html":{"url":"lab/lab1/kern/init/init.html","title":"init","keywords":"","body":"#include #include #include #include #include #include #include #include #include #include #include int kern_init(void) __attribute__((noreturn)); void grade_backtrace(void); static void lab1_switch_test(void); int kern_init(void) { extern char edata[], end[]; memset(edata, 0, end - edata); cons_init(); // init the console const char *message = \"(THU.CST) os is loading ...\"; cprintf(\"%s\\n\\n\", message); print_kerninfo(); grade_backtrace(); pmm_init(); // init physical memory management pic_init(); // init interrupt controller idt_init(); // init interrupt descriptor table clock_init(); // init clock interrupt intr_enable(); // enable irq interrupt //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test() // user/kernel mode switch test //lab1_switch_test(); /* do nothing */ while (1); } void __attribute__((noinline)) grade_backtrace2(int arg0, int arg1, int arg2, int arg3) { mon_backtrace(0, NULL, NULL); } void __attribute__((noinline)) grade_backtrace1(int arg0, int arg1) { grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1); } void __attribute__((noinline)) grade_backtrace0(int arg0, int arg1, int arg2) { grade_backtrace1(arg0, arg2); } void grade_backtrace(void) { grade_backtrace0(0, (int)kern_init, 0xffff0000); } static void lab1_print_cur_status(void) { static int round = 0; uint16_t reg1, reg2, reg3, reg4; asm volatile ( \"mov %%cs, %0;\" \"mov %%ds, %1;\" \"mov %%es, %2;\" \"mov %%ss, %3;\" : \"=m\"(reg1), \"=m\"(reg2), \"=m\"(reg3), \"=m\"(reg4)); cprintf(\"%d: @ring %d\\n\", round, reg1 & 3); cprintf(\"%d: cs = %x\\n\", round, reg1); cprintf(\"%d: ds = %x\\n\", round, reg2); cprintf(\"%d: es = %x\\n\", round, reg3); cprintf(\"%d: ss = %x\\n\", round, reg4); round ++; } static void lab1_switch_to_user(void) { //LAB1 CHALLENGE 1 : TODO } static void lab1_switch_to_kernel(void) { //LAB1 CHALLENGE 1 : TODO } static void lab1_switch_test(void) { lab1_print_cur_status(); cprintf(\"+++ switch to user mode +++\\n\"); lab1_switch_to_user(); lab1_print_cur_status(); cprintf(\"+++ switch to kernel mode +++\\n\"); lab1_switch_to_kernel(); lab1_print_cur_status(); } const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/libs/":{"url":"lab/lab1/kern/libs/","title":"libs","keywords":"","body":"libs const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/libs/readline.html":{"url":"lab/lab1/kern/libs/readline.html","title":"readline","keywords":"","body":"#include #define BUFSIZE 1024 static char buf[BUFSIZE]; /* * * readline - get a line from stdin * @prompt: the string to be written to stdout * * The readline() function will write the input string @prompt to * stdout first. If the @prompt is NULL or the empty string, * no prompt is issued. * * This function will keep on reading characters and saving them to buffer * 'buf' until '\\n' or '\\r' is encountered. * * Note that, if the length of string that will be read is longer than * buffer size, the end of string will be discarded. * * The readline() function returns the text of the line read. If some errors * are happened, NULL is returned. The return value is a global variable, * thus it should be copied before it is used. * */ char * readline(const char *prompt) { if (prompt != NULL) { cprintf(\"%s\", prompt); } int i = 0, c; while (1) { c = getchar(); if (c = ' ' && i 0) { cputchar(c); i --; } else if (c == '\\n' || c == '\\r') { cputchar(c); buf[i] = '\\0'; return buf; } } } const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/mm/":{"url":"lab/lab1/kern/mm/","title":"mm","keywords":"","body":"mm const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/mm/pmm.html":{"url":"lab/lab1/kern/mm/pmm.html","title":"pmm","keywords":"","body":"#include #include #include #include #include /* * * Task State Segment: * * The TSS may reside anywhere in memory. A special segment register called * the Task Register (TR) holds a segment selector that points a valid TSS * segment descriptor which resides in the GDT. Therefore, to use a TSS * the following must be done in function gdt_init: * - create a TSS descriptor entry in GDT * - add enough information to the TSS in memory as needed * - load the TR register with a segment selector for that segment * * There are several fileds in TSS for specifying the new stack pointer when a * privilege level change happens. But only the fields SS0 and ESP0 are useful * in our os kernel. * * The field SS0 contains the stack segment selector for CPL = 0, and the ESP0 * contains the new ESP value for CPL = 0. When an interrupt happens in protected * mode, the x86 CPU will look in the TSS for SS0 and ESP0 and load their value * into SS and ESP respectively. * */ static struct taskstate ts = {0}; /* * * Global Descriptor Table: * * The kernel and user segments are identical (except for the DPL). To load * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the * segments for the user and the kernel. Defined as follows: * - 0x0 : unused (always faults -- for trapping NULL far pointers) * - 0x8 : kernel code segment * - 0x10: kernel data segment * - 0x18: user code segment * - 0x20: user data segment * - 0x28: defined for tss, initialized in gdt_init * */ static struct segdesc gdt[] = { SEG_NULL, [SEG_KTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_KERNEL), [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL), [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER), [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER), [SEG_TSS] = SEG_NULL, }; static struct pseudodesc gdt_pd = { sizeof(gdt) - 1, (uint32_t)gdt }; /* * * lgdt - load the global descriptor table register and reset the * data/code segement registers for kernel. * */ static inline void lgdt(struct pseudodesc *pd) { asm volatile (\"lgdt (%0)\" :: \"r\" (pd)); asm volatile (\"movw %%ax, %%gs\" :: \"a\" (USER_DS)); asm volatile (\"movw %%ax, %%fs\" :: \"a\" (USER_DS)); asm volatile (\"movw %%ax, %%es\" :: \"a\" (KERNEL_DS)); asm volatile (\"movw %%ax, %%ds\" :: \"a\" (KERNEL_DS)); asm volatile (\"movw %%ax, %%ss\" :: \"a\" (KERNEL_DS)); // reload cs asm volatile (\"ljmp %0, $1f\\n 1:\\n\" :: \"i\" (KERNEL_CS)); } /* temporary kernel stack */ uint8_t stack0[1024]; /* gdt_init - initialize the default GDT and TSS */ static void gdt_init(void) { // Setup a TSS so that we can get the right stack when we trap from // user to the kernel. But not safe here, it's only a temporary value, // it will be set to KSTACKTOP in lab2. ts.ts_esp0 = (uint32_t)&stack0 + sizeof(stack0); ts.ts_ss0 = KERNEL_DS; // initialize the TSS filed of the gdt gdt[SEG_TSS] = SEG16(STS_T32A, (uint32_t)&ts, sizeof(ts), DPL_KERNEL); gdt[SEG_TSS].sd_s = 0; // reload all segment registers lgdt(&gdt_pd); // load the TSS ltr(GD_TSS); } /* pmm_init - initialize the physical memory management */ void pmm_init(void) { gdt_init(); } const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/trap/":{"url":"lab/lab1/kern/trap/","title":"trap","keywords":"","body":"trap const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/trap/trap.html":{"url":"lab/lab1/kern/trap/trap.html","title":"trap","keywords":"","body":"#include #include #include #include #include #include #include #include #include #include #define TICK_NUM 100 static void print_ticks() { cprintf(\"%d ticks\\n\",TICK_NUM); #ifdef DEBUG_GRADE cprintf(\"End of Test.\\n\"); panic(\"EOT: kernel seems ok.\"); #endif } /* * * Interrupt descriptor table: * * Must be built at run time because shifted function addresses can't * be represented in relocation records. * */ static struct gatedesc idt[256] = {{0}}; static struct pseudodesc idt_pd = { sizeof(idt) - 1, (uintptr_t)idt }; /* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */ void idt_init(void) { /* LAB1 YOUR CODE : STEP 2 */ /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)? * All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ? * __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c * (try \"make\" command in lab1, then you will find vector.S in kern/trap DIR) * You can use \"extern uintptr_t __vectors[];\" to define this extern variable which will be used later. * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT). * Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction. * You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more. * Notice: the argument of lidt is idt_pd. try to find it! */ } static const char * trapname(int trapno) { static const char * const excnames[] = { \"Divide error\", \"Debug\", \"Non-Maskable Interrupt\", \"Breakpoint\", \"Overflow\", \"BOUND Range Exceeded\", \"Invalid Opcode\", \"Device Not Available\", \"Double Fault\", \"Coprocessor Segment Overrun\", \"Invalid TSS\", \"Segment Not Present\", \"Stack Fault\", \"General Protection\", \"Page Fault\", \"(unknown trap)\", \"x87 FPU Floating-Point Error\", \"Alignment Check\", \"Machine-Check\", \"SIMD Floating-Point Exception\" }; if (trapno = IRQ_OFFSET && trapno tf_cs == (uint16_t)KERNEL_CS); } static const char *IA32flags[] = { \"CF\", NULL, \"PF\", NULL, \"AF\", NULL, \"ZF\", \"SF\", \"TF\", \"IF\", \"DF\", \"OF\", NULL, NULL, \"NT\", NULL, \"RF\", \"VM\", \"AC\", \"VIF\", \"VIP\", \"ID\", NULL, NULL, }; void print_trapframe(struct trapframe *tf) { cprintf(\"trapframe at %p\\n\", tf); print_regs(&tf->tf_regs); cprintf(\" ds 0x----%04x\\n\", tf->tf_ds); cprintf(\" es 0x----%04x\\n\", tf->tf_es); cprintf(\" fs 0x----%04x\\n\", tf->tf_fs); cprintf(\" gs 0x----%04x\\n\", tf->tf_gs); cprintf(\" trap 0x%08x %s\\n\", tf->tf_trapno, trapname(tf->tf_trapno)); cprintf(\" err 0x%08x\\n\", tf->tf_err); cprintf(\" eip 0x%08x\\n\", tf->tf_eip); cprintf(\" cs 0x----%04x\\n\", tf->tf_cs); cprintf(\" flag 0x%08x \", tf->tf_eflags); int i, j; for (i = 0, j = 1; i tf_eflags & j) && IA32flags[i] != NULL) { cprintf(\"%s,\", IA32flags[i]); } } cprintf(\"IOPL=%d\\n\", (tf->tf_eflags & FL_IOPL_MASK) >> 12); if (!trap_in_kernel(tf)) { cprintf(\" esp 0x%08x\\n\", tf->tf_esp); cprintf(\" ss 0x----%04x\\n\", tf->tf_ss); } } void print_regs(struct pushregs *regs) { cprintf(\" edi 0x%08x\\n\", regs->reg_edi); cprintf(\" esi 0x%08x\\n\", regs->reg_esi); cprintf(\" ebp 0x%08x\\n\", regs->reg_ebp); cprintf(\" oesp 0x%08x\\n\", regs->reg_oesp); cprintf(\" ebx 0x%08x\\n\", regs->reg_ebx); cprintf(\" edx 0x%08x\\n\", regs->reg_edx); cprintf(\" ecx 0x%08x\\n\", regs->reg_ecx); cprintf(\" eax 0x%08x\\n\", regs->reg_eax); } /* trap_dispatch - dispatch based on what type of trap occurred */ static void trap_dispatch(struct trapframe *tf) { char c; switch (tf->tf_trapno) { case IRQ_OFFSET + IRQ_TIMER: /* LAB1 YOUR CODE : STEP 3 */ /* handle the timer interrupt */ /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks(). * (3) Too Simple? Yes, I think so! */ break; case IRQ_OFFSET + IRQ_COM1: c = cons_getc(); cprintf(\"serial [%03d] %c\\n\", c, c); break; case IRQ_OFFSET + IRQ_KBD: c = cons_getc(); cprintf(\"kbd [%03d] %c\\n\", c, c); break; //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes. case T_SWITCH_TOU: case T_SWITCH_TOK: panic(\"T_SWITCH_** ??\\n\"); break; case IRQ_OFFSET + IRQ_IDE1: case IRQ_OFFSET + IRQ_IDE2: /* do nothing */ break; default: // in kernel, it must be a mistake if ((tf->tf_cs & 3) == 0) { print_trapframe(tf); panic(\"unexpected trap in kernel.\\n\"); } } } /* * * trap - handles or dispatches an exception/interrupt. if and when trap() returns, * the code in kern/trap/trapentry.S restores the old CPU state saved in the * trapframe and then uses the iret instruction to return from the exception. * */ void trap(struct trapframe *tf) { // dispatch based on what type of trap occurred trap_dispatch(tf); } const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/trap/trapentry.html":{"url":"lab/lab1/kern/trap/trapentry.html","title":"trapentry","keywords":"","body":"#include # vectors.S sends all traps here. .text .globl __alltraps __alltraps: # push registers to build a trap frame # therefore make the stack look like a struct trapframe pushl %ds pushl %es pushl %fs pushl %gs pushal # load GD_KDATA into %ds and %es to set up data segments for kernel movl $GD_KDATA, %eax movw %ax, %ds movw %ax, %es # push %esp to pass a pointer to the trapframe as an argument to trap() pushl %esp # call trap(tf), where tf=%esp call trap # pop the pushed stack pointer popl %esp # return falls through to trapret... .globl __trapret __trapret: # restore registers from stack popal # restore %ds, %es, %fs and %gs popl %gs popl %fs popl %es popl %ds # get rid of the trap number and error code addl $0x8, %esp iret const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/kern/trap/vectors.html":{"url":"lab/lab1/kern/trap/vectors.html","title":"vectors","keywords":"","body":"# handler .text .globl __alltraps .globl vector0 vector0: pushl $0 pushl $0 jmp __alltraps .globl vector1 vector1: pushl $0 pushl $1 jmp __alltraps .globl vector2 vector2: pushl $0 pushl $2 jmp __alltraps .globl vector3 vector3: pushl $0 pushl $3 jmp __alltraps .globl vector4 vector4: pushl $0 pushl $4 jmp __alltraps .globl vector5 vector5: pushl $0 pushl $5 jmp __alltraps .globl vector6 vector6: pushl $0 pushl $6 jmp __alltraps .globl vector7 vector7: pushl $0 pushl $7 jmp __alltraps .globl vector8 vector8: pushl $8 jmp __alltraps .globl vector9 vector9: pushl $0 pushl $9 jmp __alltraps .globl vector10 vector10: pushl $10 jmp __alltraps .globl vector11 vector11: pushl $11 jmp __alltraps .globl vector12 vector12: pushl $12 jmp __alltraps .globl vector13 vector13: pushl $13 jmp __alltraps .globl vector14 vector14: pushl $14 jmp __alltraps .globl vector15 vector15: pushl $0 pushl $15 jmp __alltraps .globl vector16 vector16: pushl $0 pushl $16 jmp __alltraps .globl vector17 vector17: pushl $17 jmp __alltraps .globl vector18 vector18: pushl $0 pushl $18 jmp __alltraps .globl vector19 vector19: pushl $0 pushl $19 jmp __alltraps .globl vector20 vector20: pushl $0 pushl $20 jmp __alltraps .globl vector21 vector21: pushl $0 pushl $21 jmp __alltraps .globl vector22 vector22: pushl $0 pushl $22 jmp __alltraps .globl vector23 vector23: pushl $0 pushl $23 jmp __alltraps .globl vector24 vector24: pushl $0 pushl $24 jmp __alltraps .globl vector25 vector25: pushl $0 pushl $25 jmp __alltraps .globl vector26 vector26: pushl $0 pushl $26 jmp __alltraps .globl vector27 vector27: pushl $0 pushl $27 jmp __alltraps .globl vector28 vector28: pushl $0 pushl $28 jmp __alltraps .globl vector29 vector29: pushl $0 pushl $29 jmp __alltraps .globl vector30 vector30: pushl $0 pushl $30 jmp __alltraps .globl vector31 vector31: pushl $0 pushl $31 jmp __alltraps .globl vector32 vector32: pushl $0 pushl $32 jmp __alltraps .globl vector33 vector33: pushl $0 pushl $33 jmp __alltraps .globl vector34 vector34: pushl $0 pushl $34 jmp __alltraps .globl vector35 vector35: pushl $0 pushl $35 jmp __alltraps .globl vector36 vector36: pushl $0 pushl $36 jmp __alltraps .globl vector37 vector37: pushl $0 pushl $37 jmp __alltraps .globl vector38 vector38: pushl $0 pushl $38 jmp __alltraps .globl vector39 vector39: pushl $0 pushl $39 jmp __alltraps .globl vector40 vector40: pushl $0 pushl $40 jmp __alltraps .globl vector41 vector41: pushl $0 pushl $41 jmp __alltraps .globl vector42 vector42: pushl $0 pushl $42 jmp __alltraps .globl vector43 vector43: pushl $0 pushl $43 jmp __alltraps .globl vector44 vector44: pushl $0 pushl $44 jmp __alltraps .globl vector45 vector45: pushl $0 pushl $45 jmp __alltraps .globl vector46 vector46: pushl $0 pushl $46 jmp __alltraps .globl vector47 vector47: pushl $0 pushl $47 jmp __alltraps .globl vector48 vector48: pushl $0 pushl $48 jmp __alltraps .globl vector49 vector49: pushl $0 pushl $49 jmp __alltraps .globl vector50 vector50: pushl $0 pushl $50 jmp __alltraps .globl vector51 vector51: pushl $0 pushl $51 jmp __alltraps .globl vector52 vector52: pushl $0 pushl $52 jmp __alltraps .globl vector53 vector53: pushl $0 pushl $53 jmp __alltraps .globl vector54 vector54: pushl $0 pushl $54 jmp __alltraps .globl vector55 vector55: pushl $0 pushl $55 jmp __alltraps .globl vector56 vector56: pushl $0 pushl $56 jmp __alltraps .globl vector57 vector57: pushl $0 pushl $57 jmp __alltraps .globl vector58 vector58: pushl $0 pushl $58 jmp __alltraps .globl vector59 vector59: pushl $0 pushl $59 jmp __alltraps .globl vector60 vector60: pushl $0 pushl $60 jmp __alltraps .globl vector61 vector61: pushl $0 pushl $61 jmp __alltraps .globl vector62 vector62: pushl $0 pushl $62 jmp __alltraps .globl vector63 vector63: pushl $0 pushl $63 jmp __alltraps .globl vector64 vector64: pushl $0 pushl $64 jmp __alltraps .globl vector65 vector65: pushl $0 pushl $65 jmp __alltraps .globl vector66 vector66: pushl $0 pushl $66 jmp __alltraps .globl vector67 vector67: pushl $0 pushl $67 jmp __alltraps .globl vector68 vector68: pushl $0 pushl $68 jmp __alltraps .globl vector69 vector69: pushl $0 pushl $69 jmp __alltraps .globl vector70 vector70: pushl $0 pushl $70 jmp __alltraps .globl vector71 vector71: pushl $0 pushl $71 jmp __alltraps .globl vector72 vector72: pushl $0 pushl $72 jmp __alltraps .globl vector73 vector73: pushl $0 pushl $73 jmp __alltraps .globl vector74 vector74: pushl $0 pushl $74 jmp __alltraps .globl vector75 vector75: pushl $0 pushl $75 jmp __alltraps .globl vector76 vector76: pushl $0 pushl $76 jmp __alltraps .globl vector77 vector77: pushl $0 pushl $77 jmp __alltraps .globl vector78 vector78: pushl $0 pushl $78 jmp __alltraps .globl vector79 vector79: pushl $0 pushl $79 jmp __alltraps .globl vector80 vector80: pushl $0 pushl $80 jmp __alltraps .globl vector81 vector81: pushl $0 pushl $81 jmp __alltraps .globl vector82 vector82: pushl $0 pushl $82 jmp __alltraps .globl vector83 vector83: pushl $0 pushl $83 jmp __alltraps .globl vector84 vector84: pushl $0 pushl $84 jmp __alltraps .globl vector85 vector85: pushl $0 pushl $85 jmp __alltraps .globl vector86 vector86: pushl $0 pushl $86 jmp __alltraps .globl vector87 vector87: pushl $0 pushl $87 jmp __alltraps .globl vector88 vector88: pushl $0 pushl $88 jmp __alltraps .globl vector89 vector89: pushl $0 pushl $89 jmp __alltraps .globl vector90 vector90: pushl $0 pushl $90 jmp __alltraps .globl vector91 vector91: pushl $0 pushl $91 jmp __alltraps .globl vector92 vector92: pushl $0 pushl $92 jmp __alltraps .globl vector93 vector93: pushl $0 pushl $93 jmp __alltraps .globl vector94 vector94: pushl $0 pushl $94 jmp __alltraps .globl vector95 vector95: pushl $0 pushl $95 jmp __alltraps .globl vector96 vector96: pushl $0 pushl $96 jmp __alltraps .globl vector97 vector97: pushl $0 pushl $97 jmp __alltraps .globl vector98 vector98: pushl $0 pushl $98 jmp __alltraps .globl vector99 vector99: pushl $0 pushl $99 jmp __alltraps .globl vector100 vector100: pushl $0 pushl $100 jmp __alltraps .globl vector101 vector101: pushl $0 pushl $101 jmp __alltraps .globl vector102 vector102: pushl $0 pushl $102 jmp __alltraps .globl vector103 vector103: pushl $0 pushl $103 jmp __alltraps .globl vector104 vector104: pushl $0 pushl $104 jmp __alltraps .globl vector105 vector105: pushl $0 pushl $105 jmp __alltraps .globl vector106 vector106: pushl $0 pushl $106 jmp __alltraps .globl vector107 vector107: pushl $0 pushl $107 jmp __alltraps .globl vector108 vector108: pushl $0 pushl $108 jmp __alltraps .globl vector109 vector109: pushl $0 pushl $109 jmp __alltraps .globl vector110 vector110: pushl $0 pushl $110 jmp __alltraps .globl vector111 vector111: pushl $0 pushl $111 jmp __alltraps .globl vector112 vector112: pushl $0 pushl $112 jmp __alltraps .globl vector113 vector113: pushl $0 pushl $113 jmp __alltraps .globl vector114 vector114: pushl $0 pushl $114 jmp __alltraps .globl vector115 vector115: pushl $0 pushl $115 jmp __alltraps .globl vector116 vector116: pushl $0 pushl $116 jmp __alltraps .globl vector117 vector117: pushl $0 pushl $117 jmp __alltraps .globl vector118 vector118: pushl $0 pushl $118 jmp __alltraps .globl vector119 vector119: pushl $0 pushl $119 jmp __alltraps .globl vector120 vector120: pushl $0 pushl $120 jmp __alltraps .globl vector121 vector121: pushl $0 pushl $121 jmp __alltraps .globl vector122 vector122: pushl $0 pushl $122 jmp __alltraps .globl vector123 vector123: pushl $0 pushl $123 jmp __alltraps .globl vector124 vector124: pushl $0 pushl $124 jmp __alltraps .globl vector125 vector125: pushl $0 pushl $125 jmp __alltraps .globl vector126 vector126: pushl $0 pushl $126 jmp __alltraps .globl vector127 vector127: pushl $0 pushl $127 jmp __alltraps .globl vector128 vector128: pushl $0 pushl $128 jmp __alltraps .globl vector129 vector129: pushl $0 pushl $129 jmp __alltraps .globl vector130 vector130: pushl $0 pushl $130 jmp __alltraps .globl vector131 vector131: pushl $0 pushl $131 jmp __alltraps .globl vector132 vector132: pushl $0 pushl $132 jmp __alltraps .globl vector133 vector133: pushl $0 pushl $133 jmp __alltraps .globl vector134 vector134: pushl $0 pushl $134 jmp __alltraps .globl vector135 vector135: pushl $0 pushl $135 jmp __alltraps .globl vector136 vector136: pushl $0 pushl $136 jmp __alltraps .globl vector137 vector137: pushl $0 pushl $137 jmp __alltraps .globl vector138 vector138: pushl $0 pushl $138 jmp __alltraps .globl vector139 vector139: pushl $0 pushl $139 jmp __alltraps .globl vector140 vector140: pushl $0 pushl $140 jmp __alltraps .globl vector141 vector141: pushl $0 pushl $141 jmp __alltraps .globl vector142 vector142: pushl $0 pushl $142 jmp __alltraps .globl vector143 vector143: pushl $0 pushl $143 jmp __alltraps .globl vector144 vector144: pushl $0 pushl $144 jmp __alltraps .globl vector145 vector145: pushl $0 pushl $145 jmp __alltraps .globl vector146 vector146: pushl $0 pushl $146 jmp __alltraps .globl vector147 vector147: pushl $0 pushl $147 jmp __alltraps .globl vector148 vector148: pushl $0 pushl $148 jmp __alltraps .globl vector149 vector149: pushl $0 pushl $149 jmp __alltraps .globl vector150 vector150: pushl $0 pushl $150 jmp __alltraps .globl vector151 vector151: pushl $0 pushl $151 jmp __alltraps .globl vector152 vector152: pushl $0 pushl $152 jmp __alltraps .globl vector153 vector153: pushl $0 pushl $153 jmp __alltraps .globl vector154 vector154: pushl $0 pushl $154 jmp __alltraps .globl vector155 vector155: pushl $0 pushl $155 jmp __alltraps .globl vector156 vector156: pushl $0 pushl $156 jmp __alltraps .globl vector157 vector157: pushl $0 pushl $157 jmp __alltraps .globl vector158 vector158: pushl $0 pushl $158 jmp __alltraps .globl vector159 vector159: pushl $0 pushl $159 jmp __alltraps .globl vector160 vector160: pushl $0 pushl $160 jmp __alltraps .globl vector161 vector161: pushl $0 pushl $161 jmp __alltraps .globl vector162 vector162: pushl $0 pushl $162 jmp __alltraps .globl vector163 vector163: pushl $0 pushl $163 jmp __alltraps .globl vector164 vector164: pushl $0 pushl $164 jmp __alltraps .globl vector165 vector165: pushl $0 pushl $165 jmp __alltraps .globl vector166 vector166: pushl $0 pushl $166 jmp __alltraps .globl vector167 vector167: pushl $0 pushl $167 jmp __alltraps .globl vector168 vector168: pushl $0 pushl $168 jmp __alltraps .globl vector169 vector169: pushl $0 pushl $169 jmp __alltraps .globl vector170 vector170: pushl $0 pushl $170 jmp __alltraps .globl vector171 vector171: pushl $0 pushl $171 jmp __alltraps .globl vector172 vector172: pushl $0 pushl $172 jmp __alltraps .globl vector173 vector173: pushl $0 pushl $173 jmp __alltraps .globl vector174 vector174: pushl $0 pushl $174 jmp __alltraps .globl vector175 vector175: pushl $0 pushl $175 jmp __alltraps .globl vector176 vector176: pushl $0 pushl $176 jmp __alltraps .globl vector177 vector177: pushl $0 pushl $177 jmp __alltraps .globl vector178 vector178: pushl $0 pushl $178 jmp __alltraps .globl vector179 vector179: pushl $0 pushl $179 jmp __alltraps .globl vector180 vector180: pushl $0 pushl $180 jmp __alltraps .globl vector181 vector181: pushl $0 pushl $181 jmp __alltraps .globl vector182 vector182: pushl $0 pushl $182 jmp __alltraps .globl vector183 vector183: pushl $0 pushl $183 jmp __alltraps .globl vector184 vector184: pushl $0 pushl $184 jmp __alltraps .globl vector185 vector185: pushl $0 pushl $185 jmp __alltraps .globl vector186 vector186: pushl $0 pushl $186 jmp __alltraps .globl vector187 vector187: pushl $0 pushl $187 jmp __alltraps .globl vector188 vector188: pushl $0 pushl $188 jmp __alltraps .globl vector189 vector189: pushl $0 pushl $189 jmp __alltraps .globl vector190 vector190: pushl $0 pushl $190 jmp __alltraps .globl vector191 vector191: pushl $0 pushl $191 jmp __alltraps .globl vector192 vector192: pushl $0 pushl $192 jmp __alltraps .globl vector193 vector193: pushl $0 pushl $193 jmp __alltraps .globl vector194 vector194: pushl $0 pushl $194 jmp __alltraps .globl vector195 vector195: pushl $0 pushl $195 jmp __alltraps .globl vector196 vector196: pushl $0 pushl $196 jmp __alltraps .globl vector197 vector197: pushl $0 pushl $197 jmp __alltraps .globl vector198 vector198: pushl $0 pushl $198 jmp __alltraps .globl vector199 vector199: pushl $0 pushl $199 jmp __alltraps .globl vector200 vector200: pushl $0 pushl $200 jmp __alltraps .globl vector201 vector201: pushl $0 pushl $201 jmp __alltraps .globl vector202 vector202: pushl $0 pushl $202 jmp __alltraps .globl vector203 vector203: pushl $0 pushl $203 jmp __alltraps .globl vector204 vector204: pushl $0 pushl $204 jmp __alltraps .globl vector205 vector205: pushl $0 pushl $205 jmp __alltraps .globl vector206 vector206: pushl $0 pushl $206 jmp __alltraps .globl vector207 vector207: pushl $0 pushl $207 jmp __alltraps .globl vector208 vector208: pushl $0 pushl $208 jmp __alltraps .globl vector209 vector209: pushl $0 pushl $209 jmp __alltraps .globl vector210 vector210: pushl $0 pushl $210 jmp __alltraps .globl vector211 vector211: pushl $0 pushl $211 jmp __alltraps .globl vector212 vector212: pushl $0 pushl $212 jmp __alltraps .globl vector213 vector213: pushl $0 pushl $213 jmp __alltraps .globl vector214 vector214: pushl $0 pushl $214 jmp __alltraps .globl vector215 vector215: pushl $0 pushl $215 jmp __alltraps .globl vector216 vector216: pushl $0 pushl $216 jmp __alltraps .globl vector217 vector217: pushl $0 pushl $217 jmp __alltraps .globl vector218 vector218: pushl $0 pushl $218 jmp __alltraps .globl vector219 vector219: pushl $0 pushl $219 jmp __alltraps .globl vector220 vector220: pushl $0 pushl $220 jmp __alltraps .globl vector221 vector221: pushl $0 pushl $221 jmp __alltraps .globl vector222 vector222: pushl $0 pushl $222 jmp __alltraps .globl vector223 vector223: pushl $0 pushl $223 jmp __alltraps .globl vector224 vector224: pushl $0 pushl $224 jmp __alltraps .globl vector225 vector225: pushl $0 pushl $225 jmp __alltraps .globl vector226 vector226: pushl $0 pushl $226 jmp __alltraps .globl vector227 vector227: pushl $0 pushl $227 jmp __alltraps .globl vector228 vector228: pushl $0 pushl $228 jmp __alltraps .globl vector229 vector229: pushl $0 pushl $229 jmp __alltraps .globl vector230 vector230: pushl $0 pushl $230 jmp __alltraps .globl vector231 vector231: pushl $0 pushl $231 jmp __alltraps .globl vector232 vector232: pushl $0 pushl $232 jmp __alltraps .globl vector233 vector233: pushl $0 pushl $233 jmp __alltraps .globl vector234 vector234: pushl $0 pushl $234 jmp __alltraps .globl vector235 vector235: pushl $0 pushl $235 jmp __alltraps .globl vector236 vector236: pushl $0 pushl $236 jmp __alltraps .globl vector237 vector237: pushl $0 pushl $237 jmp __alltraps .globl vector238 vector238: pushl $0 pushl $238 jmp __alltraps .globl vector239 vector239: pushl $0 pushl $239 jmp __alltraps .globl vector240 vector240: pushl $0 pushl $240 jmp __alltraps .globl vector241 vector241: pushl $0 pushl $241 jmp __alltraps .globl vector242 vector242: pushl $0 pushl $242 jmp __alltraps .globl vector243 vector243: pushl $0 pushl $243 jmp __alltraps .globl vector244 vector244: pushl $0 pushl $244 jmp __alltraps .globl vector245 vector245: pushl $0 pushl $245 jmp __alltraps .globl vector246 vector246: pushl $0 pushl $246 jmp __alltraps .globl vector247 vector247: pushl $0 pushl $247 jmp __alltraps .globl vector248 vector248: pushl $0 pushl $248 jmp __alltraps .globl vector249 vector249: pushl $0 pushl $249 jmp __alltraps .globl vector250 vector250: pushl $0 pushl $250 jmp __alltraps .globl vector251 vector251: pushl $0 pushl $251 jmp __alltraps .globl vector252 vector252: pushl $0 pushl $252 jmp __alltraps .globl vector253 vector253: pushl $0 pushl $253 jmp __alltraps .globl vector254 vector254: pushl $0 pushl $254 jmp __alltraps .globl vector255 vector255: pushl $0 pushl $255 jmp __alltraps # vector table .data .globl __vectors __vectors: .long vector0 .long vector1 .long vector2 .long vector3 .long vector4 .long vector5 .long vector6 .long vector7 .long vector8 .long vector9 .long vector10 .long vector11 .long vector12 .long vector13 .long vector14 .long vector15 .long vector16 .long vector17 .long vector18 .long vector19 .long vector20 .long vector21 .long vector22 .long vector23 .long vector24 .long vector25 .long vector26 .long vector27 .long vector28 .long vector29 .long vector30 .long vector31 .long vector32 .long vector33 .long vector34 .long vector35 .long vector36 .long vector37 .long vector38 .long vector39 .long vector40 .long vector41 .long vector42 .long vector43 .long vector44 .long vector45 .long vector46 .long vector47 .long vector48 .long vector49 .long vector50 .long vector51 .long vector52 .long vector53 .long vector54 .long vector55 .long vector56 .long vector57 .long vector58 .long vector59 .long vector60 .long vector61 .long vector62 .long vector63 .long vector64 .long vector65 .long vector66 .long vector67 .long vector68 .long vector69 .long vector70 .long vector71 .long vector72 .long vector73 .long vector74 .long vector75 .long vector76 .long vector77 .long vector78 .long vector79 .long vector80 .long vector81 .long vector82 .long vector83 .long vector84 .long vector85 .long vector86 .long vector87 .long vector88 .long vector89 .long vector90 .long vector91 .long vector92 .long vector93 .long vector94 .long vector95 .long vector96 .long vector97 .long vector98 .long vector99 .long vector100 .long vector101 .long vector102 .long vector103 .long vector104 .long vector105 .long vector106 .long vector107 .long vector108 .long vector109 .long vector110 .long vector111 .long vector112 .long vector113 .long vector114 .long vector115 .long vector116 .long vector117 .long vector118 .long vector119 .long vector120 .long vector121 .long vector122 .long vector123 .long vector124 .long vector125 .long vector126 .long vector127 .long vector128 .long vector129 .long vector130 .long vector131 .long vector132 .long vector133 .long vector134 .long vector135 .long vector136 .long vector137 .long vector138 .long vector139 .long vector140 .long vector141 .long vector142 .long vector143 .long vector144 .long vector145 .long vector146 .long vector147 .long vector148 .long vector149 .long vector150 .long vector151 .long vector152 .long vector153 .long vector154 .long vector155 .long vector156 .long vector157 .long vector158 .long vector159 .long vector160 .long vector161 .long vector162 .long vector163 .long vector164 .long vector165 .long vector166 .long vector167 .long vector168 .long vector169 .long vector170 .long vector171 .long vector172 .long vector173 .long vector174 .long vector175 .long vector176 .long vector177 .long vector178 .long vector179 .long vector180 .long vector181 .long vector182 .long vector183 .long vector184 .long vector185 .long vector186 .long vector187 .long vector188 .long vector189 .long vector190 .long vector191 .long vector192 .long vector193 .long vector194 .long vector195 .long vector196 .long vector197 .long vector198 .long vector199 .long vector200 .long vector201 .long vector202 .long vector203 .long vector204 .long vector205 .long vector206 .long vector207 .long vector208 .long vector209 .long vector210 .long vector211 .long vector212 .long vector213 .long vector214 .long vector215 .long vector216 .long vector217 .long vector218 .long vector219 .long vector220 .long vector221 .long vector222 .long vector223 .long vector224 .long vector225 .long vector226 .long vector227 .long vector228 .long vector229 .long vector230 .long vector231 .long vector232 .long vector233 .long vector234 .long vector235 .long vector236 .long vector237 .long vector238 .long vector239 .long vector240 .long vector241 .long vector242 .long vector243 .long vector244 .long vector245 .long vector246 .long vector247 .long vector248 .long vector249 .long vector250 .long vector251 .long vector252 .long vector253 .long vector254 .long vector255 const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/libs/":{"url":"lab/lab1/libs/","title":"libs","keywords":"","body":"libs const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"lab/lab1/tools/":{"url":"lab/lab1/tools/","title":"tools","keywords":"","body":"tools const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"1. 编写文档.html":{"url":"1. 编写文档.html","title":"1. 编写文档","keywords":"","body":"编写文档 xxxx const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"2. 本地浏览.html":{"url":"2. 本地浏览.html","title":"2. 本地浏览","keywords":"","body":"本地浏览 xxxx const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"3. 添加插件.html":{"url":"3. 添加插件.html","title":"3. 添加插件","keywords":"","body":"添加插件 xxxx const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"3.1. 参考配置.html":{"url":"3.1. 参考配置.html","title":"3.1. 参考配置","keywords":"","body":"参考配置 xxxx const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"3.2. 评论区.html":{"url":"3.2. 评论区.html","title":"3.2. 评论区","keywords":"","body":"评论区 实现方法 xxxx 参考代码 xxxx const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"4. 部署网页.html":{"url":"4. 部署网页.html","title":"4. 部署网页","keywords":"","body":"部署网页 xxxx const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: '04fb515964c291ec14f6', clientSecret: 'd3f22dae66101b238ab91929dc6658952d0c4050', repo: 'ucore-analysis', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "}}